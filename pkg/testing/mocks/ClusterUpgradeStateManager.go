// Code generated by mockery v2.26.1. DO NOT EDIT.

package mocks

import (
	context "context"
	"errors"

	upgrade "github.com/NVIDIA/k8s-operator-libs/pkg/upgrade"
	mock "github.com/stretchr/testify/mock"
	v1alpha1 "github.com/NVIDIA/k8s-operator-libs/api/upgrade/v1alpha1"
)

// ClusterUpgradeStateManager is an autogenerated mock type for the ClusterUpgradeStateManager type
type ClusterUpgradeStateManager struct {
	mock.Mock
}

// ApplyState provides a mock function with given fields: ctx, currentState, upgradePolicy
func (_m *ClusterUpgradeStateManager) ApplyState(ctx context.Context, currentState *upgrade.ClusterUpgradeState, upgradePolicy *v1alpha1.DriverUpgradePolicySpec) error {
	if upgradePolicy.DrainSpec.PodSelector != "nvidia.com/ofed-driver-upgrade-drain.skip!=true" {
		return errors.New("Invalid Drain Label Selector")
	}

	return nil
}

// BuildState provides a mock function with given fields: ctx, namespace, driverLabels
func (_m *ClusterUpgradeStateManager) BuildState(ctx context.Context, namespace string, driverLabels map[string]string) (*upgrade.ClusterUpgradeState, error) {
	ret := _m.Called(ctx, namespace, driverLabels)

	var r0 *upgrade.ClusterUpgradeState
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]string) (*upgrade.ClusterUpgradeState, error)); ok {
		return rf(ctx, namespace, driverLabels)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]string) *upgrade.ClusterUpgradeState); ok {
		r0 = rf(ctx, namespace, driverLabels)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*upgrade.ClusterUpgradeState)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, map[string]string) error); ok {
		r1 = rf(ctx, namespace, driverLabels)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTotalManagedNodes provides a mock function with given fields: ctx, currentState
func (_m *ClusterUpgradeStateManager) GetTotalManagedNodes(ctx context.Context, currentState *upgrade.ClusterUpgradeState) int {
	ret := _m.Called(ctx, currentState)

	var r0 int
	if rf, ok := ret.Get(0).(func(context.Context, *upgrade.ClusterUpgradeState) int); ok {
		r0 = rf(ctx, currentState)
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// GetUpgradesAvailable provides a mock function with given fields: ctx, currentState, maxParallelUpgrades, maxUnavailable
func (_m *ClusterUpgradeStateManager) GetUpgradesAvailable(ctx context.Context, currentState *upgrade.ClusterUpgradeState, maxParallelUpgrades int, maxUnavailable int) int {
	ret := _m.Called(ctx, currentState, maxParallelUpgrades, maxUnavailable)

	var r0 int
	if rf, ok := ret.Get(0).(func(context.Context, *upgrade.ClusterUpgradeState, int, int) int); ok {
		r0 = rf(ctx, currentState, maxParallelUpgrades, maxUnavailable)
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// GetUpgradesDone provides a mock function with given fields: ctx, currentState
func (_m *ClusterUpgradeStateManager) GetUpgradesDone(ctx context.Context, currentState *upgrade.ClusterUpgradeState) int {
	ret := _m.Called(ctx, currentState)

	var r0 int
	if rf, ok := ret.Get(0).(func(context.Context, *upgrade.ClusterUpgradeState) int); ok {
		r0 = rf(ctx, currentState)
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// GetUpgradesFailed provides a mock function with given fields: ctx, currentState
func (_m *ClusterUpgradeStateManager) GetUpgradesFailed(ctx context.Context, currentState *upgrade.ClusterUpgradeState) int {
	ret := _m.Called(ctx, currentState)

	var r0 int
	if rf, ok := ret.Get(0).(func(context.Context, *upgrade.ClusterUpgradeState) int); ok {
		r0 = rf(ctx, currentState)
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// GetUpgradesInProgress provides a mock function with given fields: ctx, currentState
func (_m *ClusterUpgradeStateManager) GetUpgradesInProgress(ctx context.Context, currentState *upgrade.ClusterUpgradeState) int {
	ret := _m.Called(ctx, currentState)

	var r0 int
	if rf, ok := ret.Get(0).(func(context.Context, *upgrade.ClusterUpgradeState) int); ok {
		r0 = rf(ctx, currentState)
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// GetUpgradesPending provides a mock function with given fields: ctx, currentState
func (_m *ClusterUpgradeStateManager) GetUpgradesPending(ctx context.Context, currentState *upgrade.ClusterUpgradeState) int {
	ret := _m.Called(ctx, currentState)

	var r0 int
	if rf, ok := ret.Get(0).(func(context.Context, *upgrade.ClusterUpgradeState) int); ok {
		r0 = rf(ctx, currentState)
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// IsPodDeletionEnabled provides a mock function with given fields:
func (_m *ClusterUpgradeStateManager) IsPodDeletionEnabled() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsValidationEnabled provides a mock function with given fields:
func (_m *ClusterUpgradeStateManager) IsValidationEnabled() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// WithPodDeletionEnabled provides a mock function with given fields: filter
func (_m *ClusterUpgradeStateManager) WithPodDeletionEnabled(filter upgrade.PodDeletionFilter) *upgrade.ClusterUpgradeStateManagerImpl {
	ret := _m.Called(filter)

	var r0 *upgrade.ClusterUpgradeStateManagerImpl
	if rf, ok := ret.Get(0).(func(upgrade.PodDeletionFilter) *upgrade.ClusterUpgradeStateManagerImpl); ok {
		r0 = rf(filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*upgrade.ClusterUpgradeStateManagerImpl)
		}
	}

	return r0
}

// WithValidationEnabled provides a mock function with given fields: podSelector
func (_m *ClusterUpgradeStateManager) WithValidationEnabled(podSelector string) *upgrade.ClusterUpgradeStateManagerImpl {
	ret := _m.Called(podSelector)

	var r0 *upgrade.ClusterUpgradeStateManagerImpl
	if rf, ok := ret.Get(0).(func(string) *upgrade.ClusterUpgradeStateManagerImpl); ok {
		r0 = rf(podSelector)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*upgrade.ClusterUpgradeStateManagerImpl)
		}
	}

	return r0
}

type mockConstructorTestingTNewClusterUpgradeStateManager interface {
	mock.TestingT
	Cleanup(func())
}

// NewClusterUpgradeStateManager creates a new instance of ClusterUpgradeStateManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewClusterUpgradeStateManager(t mockConstructorTestingTNewClusterUpgradeStateManager) *ClusterUpgradeStateManager {
	mock := &ClusterUpgradeStateManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
